package de.emir.model.application.sense.impl;

import java.util.List;

import de.emir.model.application.sense.Observation;
import de.emir.model.application.sense.SensePackage;
import de.emir.model.application.sense.Sensor;
import de.emir.model.application.sense.SensorPort;
import de.emir.model.universal.core.MemberObserver;
import de.emir.model.universal.core.RSIdentifier;
import de.emir.model.universal.physics.Capability;
import de.emir.model.universal.physics.ICapability;
import de.emir.model.universal.physics.ICharacteristic;
import de.emir.model.universal.physics.Characteristic;
import de.emir.model.universal.physics.PhysicalObject;
import de.emir.model.universal.physics.RelativeEngineering2D;
import de.emir.model.universal.physics.impl.PhysicalObjectImpl;
import de.emir.model.universal.spatial.Pose;
import de.emir.tuml.ucore.runtime.NotificationType;
import de.emir.tuml.ucore.runtime.Notification;
import de.emir.tuml.ucore.runtime.UClass;
import de.emir.tuml.ucore.runtime.annotations.UMLImplementation;
import de.emir.tuml.ucore.runtime.lists.UContainmentList;


/**

 * A sensor can do (implements) sensing: that is, a sensor is any entity that can follow a sensing method and thus observe some Property of a FeatureOfInterest. Sensors may be physical devices, computational methods, a laboratory setup with a person following a method, or any other thing that can follow a Sensing Method to observe a Property.
 * [SSN]
 * 
 * @generated 
 */
@UMLImplementation(classifier = Sensor.class)
public class SensorImpl extends PhysicalObjectImpl implements Sensor  
{
	
	
	/**
	
	 * Only if the sensor is active, it will take measurements, with the 
	 * frequency defined with the attribute frequency
	 * @generated 
	 */
	private boolean mActive = false;
	/**
	
	 * The frequency in Hz, that is used to take measurements
	 * @generated 
	 */
	private int mFrequency = 0;
	/**
	 Ports (measurements) generated by this sensor 
	 * @note to observe the occurence of new measurements, put a listener to the port (@see Port)
	 * 
	 * @generated 
	 */
	private List<SensorPort> mPorts = null;

	/**
	 *	Default constructor
	 *	@generated
	 */
	public SensorImpl(){
		super();
	}
	
	/**
	 *	Default copy constructor
	 *	@generated
	 */
	public SensorImpl(final Sensor _copy) {
		super(_copy);
		mActive = _copy.getActive();
		mFrequency = _copy.getFrequency();
		mPorts = _copy.getPorts();
	}
	
	/**
	 *	Default attribute constructor
	 *	@generated
	 */
	public SensorImpl(RSIdentifier _name, List<String> _allias, String _remarks, List<MemberObserver> _observers, RSIdentifier _identifier, RelativeEngineering2D _ownedCoordinateSystem, Pose _pose, List<ICharacteristic> _characteristics, List<ICapability> _capabilities, List<PhysicalObject> _children, boolean _active, int _frequency, List<SensorPort> _ports) {
		super(_name,_allias,_remarks,_observers,_identifier,_ownedCoordinateSystem,_pose,_characteristics,_capabilities,_children);
		mActive = _active;
		mFrequency = _frequency;
		mPorts = _ports; 
	}

	/**
	 * @generated
	 */
	public UClass getUClassifier() {
		return SensePackage.Literals.Sensor;
	}

	/**
	
	 * Only if the sensor is active, it will take measurements, with the 
	 * frequency defined with the attribute frequency
	 * @generated 
	 */
	public void setActive(boolean _active) {
		if (needNotification(SensePackage.Literals.Sensor_active)){
			boolean _oldValue = mActive;
			mActive = _active;
			notify(_oldValue, mActive, SensePackage.Literals.Sensor_active, NotificationType.SET);
		}else{
			mActive = _active;
		}
	}

	/**
	
	 * Only if the sensor is active, it will take measurements, with the 
	 * frequency defined with the attribute frequency
	 * @generated 
	 */
	public boolean getActive() {
		return mActive;
	}

	/**
	
	 * The frequency in Hz, that is used to take measurements
	 * @generated 
	 */
	public void setFrequency(int _frequency) {
		if (needNotification(SensePackage.Literals.Sensor_frequency)){
			int _oldValue = mFrequency;
			mFrequency = _frequency;
			notify(_oldValue, mFrequency, SensePackage.Literals.Sensor_frequency, NotificationType.SET);
		}else{
			mFrequency = _frequency;
		}
	}

	/**
	
	 * The frequency in Hz, that is used to take measurements
	 * @generated 
	 */
	public int getFrequency() {
		return mFrequency;
	}

	/**
	 Ports (measurements) generated by this sensor 
	 * @note to observe the occurence of new measurements, put a listener to the port (@see Port)
	 * 
	 * @generated 
	 */
	public List<SensorPort> getPorts() {
		if (mPorts == null) {
			mPorts = new UContainmentList<SensorPort>(this, SensePackage.theInstance.getSensor_ports()); 
		}
		return mPorts;
	}

	

	

	
	
	//////////////////////////////////////////////////////////////////
	//							 Operations							//
	//////////////////////////////////////////////////////////////////
	
	/**
	 * @inheritDoc
	 * @generated
	 */
	public List<SensorPort> getAllPorts()
	{
		//TODO: 
		//  returns a list of all ports of this sensor 
		throw new UnsupportedOperationException("getAllPorts not yet implemented");
	}

	/**
	 * @inheritDoc
	 * @generated
	 */
	public Observation getObservation()
	{
		//TODO: 
		//  returns an observation that contains the measurments of all ports 
		throw new UnsupportedOperationException("getObservation not yet implemented");
	}

	/**
	* @generated
	*/
	@Override
	public String toString() {
		return "SensorImpl{" +
		" allias = " + getAllias() + 
		" remarks = " + getRemarks() + 
		" active = " + getActive() + 
		" frequency = " + getFrequency() + 
		"}";
	}
}
