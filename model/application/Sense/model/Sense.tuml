#import "classpath:/model/Physics.tuml"
#import "classpath:/model/Core.tuml" 

using UCore.de.*;

/**
 * The Sense Package is used to describe basic concepts of sensors and their observations. 
 * 
 * A Sensor is modeled as the physical representation of a sensing device. Each Sensor consist of at least
 * one Port, that describe a measurement, observed by the sensor, in a specific area. 
 * 
 * Besides the Sensor the Sense Package describes a basic Observation, as a container for a sensor measurement. 
 * The concrete sensor measurement is described in an inherited Observation. 
 * 
 * The third complex of the Sense Package is the description of an ErrorModel, that describes the expected measurement error 
 * for a sensor observation. 
 * 
 * \ingroup application 
 */
Model Sense { 
	package de {
		package emir { 
			package model {
				package application {
					package sense{
						
						
						abstract struct Measurement {
							/** Time, when the measurement was created */
							val Time timestamp;
							
							ref SensorPort sender; 
						}
						
						/**
						 * Contains the observed phenomenon / measurement.
						 * the associated meta informations (like observedRegion, FeatureOfInterest, ...) are stored within the referenced port
						 */
						struct Observation {
							val Time timestamp;
							
							val Measurement[*]		measurements;
						}
						
						
						/**
						 * A sensor outputs a piece of information (an observed value), the value itself being represented by an ObservationValue.
						 * [SSN] 
						 * 
						 * @note to observe the occurrence of new measurements, put a listener on the measurement Feature
						 * @note the measurement feature is defined in specialized classifiers
						 */
						@GMF(alias := "Port")
						abstract class SensorPort extends IdentifiedObject {
							/**
							 * describes the region for which the observation is valid.
							 * Is always given relative to the attribute pose of the associated sensor
							 */
							Geometry observedRegion;
//							/**
//							 * always contains the most actual observation
//							 */
//							val Observation measurement;
							
							/**
							 * optional: expected error models
							 */
							ErrorModel[*] errorModel;
							 
							/** replace the current measurement with a new one (convenience method to avoid casting, depending on the port) */
							abstract boolean setCurrentMeasurement(in Measurement measurement);
							Measurement getLatestMeasurement() const;
						}
						
						/**
						 * A sensor can do (implements) sensing: that is, a sensor is any entity that can follow a sensing method and thus observe some Property of a FeatureOfInterest. Sensors may be physical devices, computational methods, a laboratory setup with a person following a method, or any other thing that can follow a Sensing Method to observe a Property.
						 * [SSN]
						 * 
						 */
						class Sensor extends PhysicalObject {
							/**
							 * Only if the sensor is active, it will take measurements, with the 
							 * frequency defined with the attribute frequency
							 */
							boolean active;
							/**
							 * The frequency in Hz, that is used to take measurements
							 */
							int frequency;
							
							/** Ports (measurements) generated by this sensor 
							 * @note to observe the occurence of new measurements, put a listener to the port (@see Port)
							 * */
							val SensorPort[*]		ports;

							/** returns a list of all ports of this sensor */
							abstract SensorPort[*] getAllPorts();
							
							/** returns an observation that contains the measurments of all ports */
							Observation getObservation() const;
						}
						
						
						abstract class Emitter extends PhysicalObject {
							/** Area / Range of the emitter. Only sensors within this area shall be capable of receiving the emitted value
							 * if the areaOfInfluence is not defined, the emitted value is visible everywhere. 
							 */
							Geometry areaOfInfluence;
						}
						
						
						/**
						 * \defgroup SensorErrorModel
						 * An error model describes the expected error for parts of the sensor Observation
						 */
						abstract class ErrorModel  {
							/** Expected type of observation */
							ref UClassifier 		 	observationType;
							/** Pointer to features, that will be affected by this error model
							 * each pointer should be positioned, relative to the observation that must inherit the observationType
							 */
							ref Pointer[*]				pointers; 
						}
						
						package ports {
							
							/** Measurement that holds the location of a not further specified object 
							 * this could be for example an GPS, Lorence or Galileo measure. Inherited structs may extend some additional 
							 * metadata like used satellites (if Satellite based sensor)*/
							class LocationPort extends SensorPort {
								val measurements.LocationMeasurement		measurement;
							}
							/** Measurement that represents the orientation of the measured object, e.g. heading. 
							 * Orientation measures may be created by compass sensors. 
							 */
							class OrientationPort extends SensorPort {
								val measurements.OrientationMeasurement		measurement; 
							}
							/** Measurement representing the velocity / speed of the measured object, e.g. could be a tachometer, 
							 * a wind sensor (wind speed), log (speed through water)
							 */
							class VelocityPort extends SensorPort {
								val measurements.VelocityMeasurement		measurement;
							}
							/**
							 * Measurement that represents the change of the orientation over time, e.g. the rotation. 
							 * This could be created by a gyroscope
							 */
							class RotationPort extends SensorPort {
								measurements.RotationMeasurement			measurement;
							}
							/** Measurement containing the temperature of something */
							class TemperaturePort extends SensorPort {
								measurements.TemperatureMeasurement			measurement;
							}
							
							class DistancePort extends SensorPort {
								//represends a single measurand
								measurements.DistanceMeasurement			measurement;
							}
							//TODO: Range scans, e.g. laser, radar, ... as RangeScanMeasurand?
							//TODO: Image Measurand
							
							/** The position Measurement differs from the LocationMeasurement in that form, that it measures the position
							 * of an external object. Within the maritime domain such a measurement may be generated by an AIS sensor but also 
							 * by an Radar (reasoned from the own position of the radar and a DistanceMeasurement) 
							 */
							class PositionPort extends SensorPort {
								measurements.PositionMeasurement			measurement; //represents another object
							}
							
							class ObjectPort extends SensorPort {
								measurements.ObjectMeasurement				measurement;
							}
							
						}
						package measurements {
							
//							enum Measurands {
//								LOCATION = 0;
//								ORIENTATION = 1;
//								VELOCITY = 2;
//								ROTATION = 3;
//								TEMPERATURE = 4;
//								DISTANCE = 5;
//								POSITION = 6;
//							} 
							
							/** Measurement that holds the location of a not further specified object 
							 * this could be for example an GPS, Lorence or Galileo measure. Inherited structs may extend some additional 
							 * metadata like used satellites (if Satellite based sensor)*/
							struct LocationMeasurement extends Measurement {
								Coordinate				location;
							}
							/** Measurement that represents the orientation of the measured object, e.g. heading. 
							 * Orientation measures may be created by compass sensors. 
							 */
							struct OrientationMeasurement extends Measurement {
								Orientation				orientation;
							}
							/** Measurement representing the velocity / speed of the measured object, e.g. could be a tachometer, 
							 * a wind sensor (wind speed), log (speed through water)
							 */
							struct VelocityMeasurement extends Measurement {
								Velocity				velocity;
							}
							/**
							 * Measurement that represents the change of the orientation over time, e.g. the rotation. 
							 * This could be created by a gyroscope
							 */
							struct RotationMeasurement extends Measurement {
								AngularVelocity			velocity;
							}
							/** Measurement containing the temperature of something */
							struct TemperatureMeasurement extends Measurement {
								Temperature				temperature;
							}
							
							struct DistanceMeasurement extends Measurement {
								//represends a single measurand
								Distance				distance;
							}
							//TODO: Range scans, e.g. laser, radar, ... as RangeScanMeasurand?
							//TODO: Image Measurand
							
							/** The position Measurement differs from the LocationMeasurement in that form, that it measures the position
							 * of an external object. Within the maritime domain such a measurement may be generated by an AIS sensor but also 
							 * by an Radar (reasoned from the own position of the radar and a DistanceMeasurement) 
							 */
							struct PositionMeasurement extends Measurement {
								LocatableObject				object; //represents another object
							}
							
							/** The position Measurement differs from the LocationMeasurement in that form, that it measures the position
							 * of an external object. Within the maritime domain such a measurement may be generated by an AIS sensor but also 
							 * by an Radar (reasoned from the own position of the radar and a DistanceMeasurement) 
							 */
							struct ObjectMeasurement extends Measurement {
								IdentifiedObject				object; //represents another object
							}
						}
					}					
				}
			}
		}		
	}
}	
